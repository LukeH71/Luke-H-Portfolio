//
//  Renderer.m
//  Game4
//
//  Created by Luke Hickey on 3/25/24.
//

#import <simd/simd.h>
#import <ModelIO/ModelIO.h>

#import "Renderer.h"

#import <iostream>

// i want:
// game thread
// rendering thread (this)

#import "gameMain.h"
#import "Shaders.h"


// For triple buffering
static const NSUInteger kMaxBuffersInFlight = 3;

static const size_t kAlignedUniformsSize = (sizeof(Uniforms) & ~0xFF) + 0x100;





@implementation Renderer
{
    
    dispatch_semaphore_t _inFlightSemaphore;
    
    gameMain *_mainGameClass;
    
    id <MTLDevice> _device;
    id <MTLCommandQueue> _commandQueue;
    
    id <MTLBuffer> _dynamicUniformBuffer;
    id <MTLRenderPipelineState> _pipelineState[2];
    id <MTLDepthStencilState> _depthState;
    id <MTLTexture> _colorMap[2];
    MTLVertexDescriptor *_mtlVertexDescriptor;

}

-(nonnull instancetype)initWithMetalKitView:(nonnull KeyboardMTKView *)view;
{
    
    self = [super init];
    if(self)
    {
        
        _device = view.device;
        _inFlightSemaphore = dispatch_semaphore_create(3); //MaxBuffersInFlight
     
        
        _mainGameClass = new gameMain(view, _device);

        view.depthStencilPixelFormat = MTLPixelFormatDepth32Float_Stencil8;
        view.colorPixelFormat = MTLPixelFormatBGRA8Unorm_sRGB;
        view.sampleCount = 1;
        
        id<MTLLibrary> defaultLibrary = [_device newDefaultLibrary];
        
        _pipelineState[0] = createLoadingScreenShaderWithView(_device, view, defaultLibrary);
        //[self _createPipelineState:0 vertexFunction:@"LoadingScreen_vertexShader" fragmentFunction:@"LoadingScreen_fragmentShader" withView:view];
        [self _loadMetalWithView:view];
        [self _loadAssets];
        
        
    }

    return self;
}

- (void)_loadMetalWithView:(nonnull MTKView *)view
{
    
    MTLDepthStencilDescriptor *depthStateDesc = [[MTLDepthStencilDescriptor alloc] init];
    depthStateDesc.depthCompareFunction = MTLCompareFunctionLess;
    depthStateDesc.depthWriteEnabled = YES;
    _depthState = [_device newDepthStencilStateWithDescriptor:depthStateDesc];

    NSUInteger uniformBufferSize = kAlignedUniformsSize * kMaxBuffersInFlight;

    _dynamicUniformBuffer = [_device newBufferWithLength:uniformBufferSize
                                                 options:MTLResourceStorageModeShared];

    _dynamicUniformBuffer.label = @"UniformBuffer";

    _commandQueue = [_device newCommandQueue];
}


- (void)_loadAssets
{
    
    /// Load assets into metal objects

    NSError *error;

    MTKTextureLoader* textureLoader = [[MTKTextureLoader alloc] initWithDevice:_device];

    NSDictionary *textureLoaderOptions =
    @{
      MTKTextureLoaderOptionTextureUsage       : @(MTLTextureUsageShaderRead),
      MTKTextureLoaderOptionTextureStorageMode : @(MTLStorageModePrivate)
      };

    _colorMap[0] = [textureLoader newTextureWithName:@"LoadingScreen"
                                      scaleFactor:1.0
                                           bundle:nil
                                          options:textureLoaderOptions
                                            error:&error];
    _colorMap[1] = [textureLoader newTextureWithName:@"Texture"
                                      scaleFactor:1.0
                                           bundle:nil
                                          options:textureLoaderOptions
                                            error:&error];

    if(!_colorMap || error)
    {
        NSLog(@"Error creating texture %@", error.localizedDescription);
    }
}



//NSRect windowFrame = _view.window.frame;
//NSRect screenFrame = _view.window.screen.frame;
//
//CGPoint center = CGPointMake(windowFrame.origin.x + windowFrame.size.width / 2.0, NSHeight(screenFrame) - windowFrame.origin.y - windowFrame.size.height / 2.0);
//if( !NSEqualRects(windowFrame, screenFrame) ) center.y += 15 ;
//CGWarpMouseCursorPosition(center);

- (void)drawInMTKView:(nonnull MTKView *)view
{
    dispatch_semaphore_wait(_inFlightSemaphore, DISPATCH_TIME_FOREVER);

    id <MTLCommandBuffer> commandBuffer = [_commandQueue commandBuffer];
    commandBuffer.label = @"MyCommand";

    __block dispatch_semaphore_t block_sema = _inFlightSemaphore;
    [commandBuffer addCompletedHandler:^(id<MTLCommandBuffer> buffer)
     {
         dispatch_semaphore_signal(block_sema);
     }];

    //_mainGameClass->bufferState();
    _mainGameClass->generateNextFrame();
    
    /// Delay getting the currentRenderPassDescriptor until we absolutely need it to avoid
    ///   holding onto the drawable and blocking the display pipeline any longer than necessary
    MTLRenderPassDescriptor* renderPassDescriptor = view.currentRenderPassDescriptor;

    if(renderPassDescriptor != nil) {
        
        /// Final pass rendering code here
        
        id <MTLRenderCommandEncoder> renderEncoder =
        [commandBuffer renderCommandEncoderWithDescriptor:renderPassDescriptor];
        renderEncoder.label = @"MyRenderEncoder";
        
        [renderEncoder pushDebugGroup:@"DrawBox"];
        
        char stage = _mainGameClass->getRenderingStage();
        
        [renderEncoder setFrontFacingWinding:MTLWindingCounterClockwise];
        [renderEncoder setCullMode:MTLCullModeBack];
        [renderEncoder setRenderPipelineState:_pipelineState[stage]];
        [renderEncoder setDepthStencilState:_depthState];
        
        
        switch(stage) {
            default:
                
                [renderEncoder setFragmentBuffer:_mainGameClass->getFragmentShaderBuffer()
                                          offset:0
                                         atIndex:0];
                
                [renderEncoder setVertexBuffer:_mainGameClass->getVertexBuffer()
                                        offset:0
                                       atIndex:0];
                
                [renderEncoder setVertexBuffer:_mainGameClass->getTexCoordBuffer()
                                        offset:0
                                       atIndex:1];
                
                [renderEncoder setVertexBuffer:_mainGameClass->getTexIndexBuffer()
                                        offset:0
                                       atIndex:2];
                
                //[renderEncoder setVertexBuffer:_mainGameClass->getVertexShaderBuffer()
//                                        offset:0
//                                       atIndex:3];
                
                NSRange textureRange = NSMakeRange(0, 2);
                
                [renderEncoder setFragmentTextures:_colorMap
                                         withRange:textureRange];
                
                [renderEncoder drawIndexedPrimitives:MTLPrimitiveTypeTriangle
                                          indexCount:18
                                           indexType:MTLIndexTypeUInt16
                                         indexBuffer:_mainGameClass->getIndicesBuffer()
                                   indexBufferOffset:0];
                
                break;
        }
        
        [renderEncoder popDebugGroup];
        
        [renderEncoder endEncoding];
        
        [commandBuffer presentDrawable:view.currentDrawable];
    }

    [commandBuffer commit];
    
}

- (void)mtkView:(nonnull MTKView *)view drawableSizeWillChange:(CGSize)size
{
    /// Respond to drawable size or orientation changes here
    
    _mainGameClass->setAspect(size.width / (float)size.height);
    
}

@end
